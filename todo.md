# TODO

## 一维动态规划

### 70 爬楼梯 / 746 最小花费爬楼梯 / fib /

拓展为[三步爬楼梯问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/solution/)

### 91 解码方法
### 639 解码方法2
### 198 打家劫舍

# 53 最大子序列和

https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/

# 5 最长回文子序列

1. 暴力破解
1. 最长公共子序列
1. 动态规划（按长度，逆序，优化空间到线性）
1. 从中间扩展
1. manacher's algorithm

# 131 切割回文字符串

1. 切分为子问题，左边是一个回文字符串，拼凑右边字符串对应子问题的结果得到原问题的结果。
1. 回溯法：从左到右不断切割回文子串，并用栈记录，一层调用嵌套加深一层，知道右侧子串为空递归结束，这时栈中内容就是一个回文子串的切分结果；之后向上回溯，完成一个调用栈进行一次出栈操作

# 132 回文字符串最小切割数

1. 分治法，
1. 回溯，
1. 中心扩展

# 二维问题

## 120 三角形最小路径和

## 64 最小路径和
  1. 滚动数组，状态压缩？
  1. 递归法 缺点是重复计算、嵌套层数可能很多

## 72 编辑距离

1. 注意边界条件

## 97 交错字符串

注意边界条件
定义f(i, j)表示子问题字符串`s1[0, i]`和`s2[0,j]`交错组成`s3[0, i+j+1]`，分解成子问题

```js
f(i,j) = s1[i] === s3[i+j+1] && f(i-1,j) || s2[j] === s3[i+j+1] && f(i, j-1)
```

注意边界条件，

1. f(-1, j)表示s1前缀（空串）和s2能否组成s3前缀，对应动态规划数组第一行
1. 相应的f(i,-1)对应第一列
1. f(-1, -1)对应左上角，对应子问题s1(空串)和s2（空串）能否交错组成s3（空串），结果是true

使用的动态规划二位数组长度是`[s1.length+1][s2.length+1]`，

此问题可以进行状态压缩，使用一维数组。

## 87 扰乱字符串？

三维dp，为什么不能排序对比？

## 139/140 单词拆分

dfs遍历凑出结果

## 115 不同的子序列/392判断子序列

1. 分治解法
1. 二维动态规划
1. 可以状态压缩的状态转移条件、一维动归数组逆序求值

https://leetcode.wang/leetcode-115-Distinct-Subsequences.html

## 392 判断子序列

1. 双指针
1. 遍历目标字符串
1. 预处理
1. 动态规划

## 单调栈相关问题

84,85,221,1127,764,42, 739,496,503,556,

1. 栈严格（非严格）递增（递减），进栈/出栈，从左到右遍历，从右到左遍历，
1. 求数组中下表为i的元素左边最近的小于i的元素位置
1. 求数组中下标为i的元素右边至少多少步找到一个大于i的元素

1. https://www.cnblogs.com/grandyang/p/8887985.html
1. https://zhuanlan.zhihu.com/p/26465701

## 排列组合算法

1. SKU全排列，深度遍历，递归

```js
    const array = [
      ['IPhone X', 'IPhone XS'],
      ['black', 'white'],
      ['64g', '256g'],
    ]
```
1. 字典序
1. 31
1. https://juejin.im/post/5de7c053518825125d1497e2
1. 77 回溯法、回溯转换为迭代实现，递归（f(n, k) = f(n-1, k-1), f(n-1, k) 分解， 转化为动态规划，
